#ifndef TrajectoryPlanner_idl
#define TrajectoryPlanner_idl

#include <BasicDataType.idl>
#include <ExtendedDataTypes.idl>
#include <InterfaceDataTypes.idl>

module Manipulation {

  enum RETURN_VALUE {
    RETVAL_OK,
    RETVAL_INVALID_PARAMETER,
    RETVAL_EMPTY_MAP,
    RETVAL_INVALID_PRECONDITION,
    RETVAL_NOT_IMPL,
    RETVAL_NOT_FOUND,
    RETVAL_UNKNOWN_ERROR
  };

  typedef string RobotIdentifier;

  typedef sequence<double> JointInfo;

  struct RobotInfo{
	RobotIdentifier RobotID;
    sequence<JointInfo> JointInfoSeq;
  }

  typedef sequence<RTC::Point3D> MeshInfo;

  struct CollisionInfo{
	  /*
	  */
  }
  struct ManipulationPlan{
	  /*
	  */
  }

  interface CollisionDetectionService{
	RETURN_VALUE isCollide(in ManipulationPlan manipInfo, in RobotInfo jointSeq, out CollisionInfo collisionInfo);
  }

  interface ManipulationPlannerService{
	RETURN_VALUE planManipulation(in RobotIdentifier robotID, in RTC::Pose3D goalPose, out ManipulatorPlan manipPlan);
  }

  interface ModelServerService{
	RETURN_VALUE getModelInfo(in RobotIdentifier robotID, out RobotInfo robotInfo);
	RETURN_VALUE getMeshInfo(in RobotIdentifier robotID, out MeshInfo meshInfo);
  }

  
  struct Node;
  typedef sequence<Node> NodeList;

  struct Node{
    string name;
    MeshInfo Mesh;
    RTC::Vector3D translation;
    RTC::Vector3D rotation;
    NodeList children;
  };

  typedef sequence<Node> MultiMesh;


  interface TrajectoryPlanner {
    RETURN_VALUE planTrajectory(in JointPose start, in JointPose goal, out JointTrajectory trajectory);
  };

    interface MeshServer {
    RETURN_VALUE getRobotMesh(out MultiMesh robots);
    RETURN_VALUE getEnvMesh(out Node env);
  };
	  
  
};


#endif
